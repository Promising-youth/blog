在学习tcp的时候，第一天学，第二天忘，纠其原因，还是对tcp的知识不是很了解。后来，仔细想了想，如果是我设计一套tcp协议，我会怎么设计，以这种思路去思考后，发现tcp协议的原理变得很通透。


# 假如我设计一个tcp协议

我们不考虑数据丢失的可能(tcp的设计，考虑了数据丢失的可能)。

首先tcp是双向通信的，对于我们这种新手来说，单向通信还不会，就一步跨个大步子，那样容易扯到O， 所以首先要考虑，*单向通信应该怎么设计*?

对于任何通信而言，首先就是需要建立连接，一般来说，单向通信建立连接的方式就是a向b放松请求，告诉b我要连接你，b向a回复请求，告诉a,我收到了你的连接请求，此时a和b就完成了a->b的单向连接。那为什么b不能向a发送数据呢，因为a并没有同意b向a发送数据。

也即单向通信，至少需要两次握手，才能建立连接，第一次握手为发送放询问接受方(send syn)，第二次握手为接收方同意(send ack)。

那么单向连接实现了，怎么实现双向连接呢。我们比葫芦画瓢，a向b握两次手实现了a->b的连接，而b再向a握两次手，是不是又实现了b->a的单向连接，这样是不是就已经是双向连接呢，是不是一个简版的tcp了呢。那么这个简版的tcp的握手流程就如下:

> ❶ a ->b : send y<br>
> ❷ b -> a : ack y+1<br>
> ❸ b -> a : send x <br>
> ❹ a -> : ack x + 1<br>

你看还不错，我们用四次握手实现了tcp连接。

但是仔细观察，你可能会发现: 
> ❷ b -> a : ack y+1<br>
> ❸ b -> a : send x <br>

这一部长得好像啊，是不是可以合并到一块呢？ 当然可以啦！ 

你看把他合并到一起，是不是就完成了tcp的简版连接呢: 
> ❶ a ->b : send y<br>
> ❷ b -> a : ack y+1,send x <br>
> ❸ a -> b: ack x + 1<br>

到这是不是就了解了为什么需要三次握手呢?
简而言之，就是前两次建立客户端向服务端的单向连接，而后两次是建立服务端向客户端的单向连接。只不过将2,3部的重合做了合并。

同样的道理，为什么挥手的时候，也需要四呢，而不是三次呢。

原因就在于挥手的时候，服务端可能还在向客户端发送数据，所以2,3部是不能被合并的，所以一般就是四次挥手。

记住其原理的关键就是，对于单向连接，无论是建立断开，都至少需要2次握手才能成立。