搭建一个小的im即时通讯，听起来挺简单，但麻雀虽小，五脏俱全，所以考虑这么个项目来练手，增强相关的计算机知识。

# 系统目标

# 系统模块

1. 过滤系统
2. 消息队列
3. 统一handle模块

# 相关技术

- tcp/udp: tcp/ip五层模型中的传输层，而下层则是网络层(ip)
- socket: 不属于tcp/ip五层模型中的任意一层，也不属于 OSI中的任一层，而是应用层和传输层隐性的一个模块，他只是tcp/udp协议的封装，如果要调用tcp和udp进行连接，一般都只能通过socket提供的接口来进行，可以理解为api。与http不同的是，一般来说socket进行的tcp连接是长连接，而http可长可短。
- select:io多路复用，采用轮询的方式去处理io流。为什么一个线程可以处理多个io流，一定要理解，io和线程之间是独立的关系，io在处理的时候，线程是可以不用阻塞的，而是去做其他事情，io有专门的处理器，比如网卡处理网络io，DMA(直接内存访问)处理硬盘和内存间的io。可以参考这个做详细了解: https://segmentfault.com/a/1190000007692223
- epoll:同样是io多路复用，与select不同的是，他会保存io流与对应的id,而不用采用轮询的方式去处理流，类似通过map的方式去处理，所以他比较高效。
- 阻塞： io多路复用是和阻塞息息相关的，对于进程阻塞，其只是将当前进程的状态标记为阻塞，之后cpu可以处理其他非阻塞的任务，而当前进程阻塞状态解除时，cpu才能接管(什么时候接管与cpu的调度有关)当前进程继续处理任务。所以阻塞并不是cpu什么都不做了，而是通过内核切换进程做其他事情。但是内核切换又通常比较慢，会切换进程上下文，做资源得转换等等，资源消耗比较多，所以频繁的阻塞也会导致频繁的进程切换，导致cpu浪费消耗资源多，且效率严重降低。而select在轮询一遍io流时，发现没有可处理的io流，则会发生阻塞，直到下一个io事件发生，select/epoll会给io事件增加回调函数，在io完成后，会唤醒当前线程。
- `ulimit -n`: linux打开最多的fd个数，tcp连接时，通常需要一个文件描述符(fd)，当系统的`ulimit -n`的数量较少时，系统的并发量会上不去，所以需要更改系统的限制。
- 心跳保活