概述
====

当使用前后端分离来做项目时，前端是8080端口，后端是80端口，不同的端口在请求时，也是跨域的请求。如果不做一些设置，请求成功，也会收不到数据。

解
==

1.  需要在服务端返回时，在header上加上: `Access-Control-Allow-Origin: *`
    字面意思，即允许任何域访问或接受。
2.  如果前端使用axios来做请求时，默认是不会自动携带本来就有的cookie的，所以对于有些需要登录的请求的，必然会失败(权限验证需要cookie嘛)，所以需要在使用axios时加上这么一行代码:
    `axios.defaults.withCredentials=true;`
3.  但此时，服务端返回的数据又无法接受了，原因在于启用了withCredentials后，返回的Access-Control-Allow-Origin不能是
    `*` ，所以修改的Access-Control-Allow-Origin为
    `http:://localhost:8080` (your ipport) ，再然后添加一个header:
    `Access-Control-Allow-Credentials: true`
    ，这个header也是必须的，字面意思。这样就大功告成了\~

cors问题
========

参考资料:<https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS>

好好读读上边的文章。
如果你的前后端分离项目中，使用axios来发起post请求，你会发现即便你设置了上边所有的要求后，你的请求依然发不过去。你查后端的日志，你也很难发现问题。
关键问题就在于cors机制，在你发送post请求前，为安全考虑，会先发送一个options请求过去，如果你的后端不允许options操作，那axios的post请求死活都不会发过去。
这个问题困扰了我一下午，最后实在想不通，所以利用 `nc -l 80`
抓包，来看前端到底发了个什么玩意到后端，这才发现问题所在。
来看下上文的这个描述:

| 跨域资源共享标准新增了一组 HTTP
  首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的
  HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的
  POST 请求），浏览器必须首先使用 OPTIONS
  方法发起一个预检请求（preflight
  request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的
  HTTP
  请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括
  Cookies 和 HTTP 认证相关数据）。
| 
| CORS请求失败会产生错误，但是为了安全，在JavaScript代码层面是无法获知到底具体是哪里出了问题。你只能查看浏览器的控制台以得知具体是哪里出现了错误。
| 
| 接下来的内容将讨论相关场景，并剖析该机制所涉及的 HTTP 首部字段。

你有可能会oh,fxxk!
那么此问题应该怎么解决呢，其实解决方法还是在于你的服务端的设置
，你可以针对某个方法来实现其options方法，或者使用一些中间件。
比如利用actix~web来构建项目~，可以使用actix~cors中间件~。或者你也可以自己写一些中间件，遇到options时直接返回200即可。
